\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{tipa}
\usepackage{cancel}
\usepackage{svg}
\usepackage{tikz}
  \usetikzlibrary{arrows}
\usepackage{array,multirow}
\usepackage[ruled, lined, linesnumbered, commentsnumbered, longend]{algorithm2e}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
  \pgfplotsset{ compat=1.18 }
\usepackage{textcomp}

\title{LEArn/TEAch Routing Algorithm for Ad-hoc Networks}
\author{Bernd Fix \texttt{<brf@hoi-polloi.org>}}

\begin{document}

\maketitle

\begin{abstract}
This document contains the technical specification for the LEArn/
TEAch routing algorithm ("LeaTea" for short; pronounced /\textipa{li:ti:}/).
It is designed for smaller\footnote{see section \ref{sec:limits} for a
description of the limiting factors.} ad-hoc networks, where peers are
connected through wireless technology with neighbors in their vincinity
(defined by the reach of the built-in sender/receiver). Given a required
density of nodes (depending on the reach), the resulting network can span
a large area. The LeaTea network is fully decentralized with no
coordinating authority in between. Peers communicate directly with
other peers (even outside the reach of their device) over a
self-organizing routing protocol.
\end{abstract}

\section{Introduction}

\paragraph{}
Efficient routing in ad-hoc networks is an on-going challenge due to
their decentralized nature. Since the emergence of wireless technologies
like 802.11 or Bluetooth in consumer devices (which more less coincides
with the public availability of the internet in the late 1990's) more
than 100 different routing algorithms for ad-hoc networks have been
proposed and implemented. While ad-hoc networks in the beginning were
focussed on personal mobile devices, the evolution of the ``Internet
of Things'' (IoT) has opened new fields of applications for ad-hoc
networks -- and ad-hoc routing algorithms.

\paragraph{}
Ad-hoc routing algorithms are usually classified into four categories:
\textit{proactive} routing (table-driven), \textit{reactive} routing
(on-demand), \textit{hybrid} (both reactive and proactive) and
\textit{hierarchical} routing. Table \ref{tbl:routing} shows the
classification of some routing algorithms that have been standardized
in RFCs or are major representatives of their class; for a more detailed
duiscussion of ad-hoc routing algorithms and their classificarion see
\cite{10.1007/978-3-642-37949-9_5}.

\begin{table}[ht]
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{|r|c|}
    \hline
    \textbf{Algorithm} & \textbf{Classification} \\
    \hline
    OLSR\footnote{Optimized Link State Routing Protocol} [RFC 3626, RFC 7181] & \multirow{2}{*}{Proactive} \\
    Babel [RFC 6126] &  \\
    \hline
    AODV\footnote{Ad-hoc On-demand Distance Vector} [RFC 3561] & \multirow{2}{*}{Reactive} \\
    DSR\footnote{Dynamic Source Routing} [RFC 4728] & \\
    \hline
    Zone Routing Protocol (ZRP) & Hybrid \\
    \hline
    CBRP (Cluster Based Routing Protocol) & \multirow{2}{*}{Hierarchical} \\
    FSR (Fisheye State Routing) & \\
    \hline
  \end{tabular}
  \caption{standardized ad.hoc routing algorithms}
  \label{tbl:routing}
\end{table}

\paragraph{}
On the internet the routing problem is
`solved' through hierarchical, centralized infrastructures both on the
physical level (cables, backbones and routers) and logical level
(assigning identifiers like IP addresses, resolving human-memo\-rable
names to identifiers and managing routes). A participating node
does not need to know much about the overall topology of the network;
it is sufficient it knows how to get an identifier from the next-level
authority and where to forward messages to other nodes (gateways).

\paragraph{}
The drawback is that a node on the internet is dependent on the good
will of any actor that is involved in this process. The messages that
a node can send or receive to any other node may be restricted by
explicit intervention (censorship) or simple mistake (faulty BGP) by
actors. A significant part of the internet is literally `invisible'
to any node at any time \cite{4146887}. Since the internet
is not only locally `controlled' by state actors but also on a global
scale by commercially-oriented entities with their own objectives,
it can become difficult for nodes to establish connections to other
nodes of its own choosing.

\paragraph{}
Of course a few of these issues are due to the fact that the internet
is really, really large these days. Ad-hoc networks -- as their name
``solution for a specific purpose'' suggests -- are currently
used on a much smaller scale and usually on a temporary basis. But
even in a relatively small network routing without authorities in a
self-organizing, self-healing way is still an active field of research.

\paragraph{}
The LEArn/TEAch routing presented in this paper provides a simple yet
effective (routing) and efficient (resource-consumption) algorithm
for smaller ad-hoc networks. It is a \textit{proactive} algorithm
in the usual sense; it uses forward tables and control messages
to spread knowledge about routes through the network. But it uses
concepts found in hierarchical routing algorithms like FSR \cite{FSR},
especially the concept of locality and the decrease in confidence in
routes to more remote peers.

\section{Overview and design principles}

\paragraph{}
The discussion of the design principles will reference details that
are only described in later sections; a first-time reader is advised
to go directly to section \ref{sec:terms} and read the rest of the
paper first. Then coming back here to get more details about the
\textit{why} after learning about the \textit{how}.

\subsection{Locality}

\paragraph{}
The basic concept of LeaTea is that of
\textit{Locality} meaning that a peer can only have direct knowledge
about its neighbors. Only these one-hop routes to neighbors are
``verified'', all other routes must be learned from neighbors. It is
easy to see that the \textit{confidence} in a route decreases with
hop count; the further another peer is (in terms of hops to reach it),
the ``fuzzier'' the route becomes. The target (or one of the
intermediate hops) might have disappeared since learning the route -
a peer just can't know for sure. All it knows is that shorter routes
are more likely to work than longer routes.

\paragraph{}
Instead of trying to fight the circumstances with control messages that
directly traverse the network (like PINGs) to check if a route is still
``good'', LeaTea embraces the restriction as a feature.
Information about the \textit{origin} routes (the one-hop routes to
neighbors) is spread by peers to neighbors periodically; neighbors use
them to \textit{derive} routes to tell its neighors how to reach the
originating peer.; these derived routes are also broadcasted to neighbors
in TEAch messages. Knowledge about routes is propagating through the
network  like ripples in a pond when a stone is thrown into it.

\paragraph{}
Like ripples this route information superimposes in peers; the LEArn
part of LeaTea (see section \ref{sec:learnTeach}) is designed to decide
what ``ripple'' to consider as a better route (e.g. if the two ripples
carry contradicting information).

\subsection{LEArn / TEAch cycle}

\paragraph{}
Each peer periodically sends out a LEArn message; the message tells
its neighbors \textit{``This is what I already know, and I want to
learn more''}. Using our previous analogy the LEArn message is the
stone thrown into the lake. The time span between two LEArn messages
of a peer is called an \textit{epoch}.
During an epoch a peer receives TEAch messages from neighbors.
These TEAch messages can be a direct response to a LEArn message
sent by the peer at the beginning of the epoch, or responses to
LEArn messages from other peers\footnote{Even peers that are not
neighbors of the receiving peer; the neighbors of my neighbor are
not necessarly my neighbors too.}

\paragraph{}
TEAch messages are only sent by peers as a response to a LEArn message;
it only includes knowledge the requester does not know yet (and knowledge
about other routes it deems interesting for others if the free space in
the message permits). A peer also receives TEAch messages it did not
ask for; this is ``extra information'' that comes in for free and
increases efficiency of the information transport, as more than one peer
can learn something new from a single TEAch message.

\subsection{Limits of the algorithm}
\label{sec:limits}

\paragraph{}
The current design of LeaTea limits the number of peers in a network
with full connectivity (each peer knows the routes to all other peers);
this restriction will of course also limit the possible use-cases for
the algorithm. But as we will see, a lot of interesting use-cases for
LeaTea still exist. Given the potential in optimization and design
improvements this number of total nodes will likely get to a higher
level. The upper limit of number of peers is impacted by two factors:

\subsubsection{Transport layer}

\paragraph{}
If we assume that peers can only send (routing-control) messages up
to a given size (defined by the  MTU\footnote{Maximum Transport Unit
as defined by the transport  mechanism (802.11,BT).}), the size of
LEArn and TEAch messages will be limited. If for example WiFi is used,
the size of a 802.11 MTU is 2304 bytes.

\subsubsection{Implementation of a LEArn message}

\paragraph{}
To communicate its complete knowledge to neighbors to receive new
information is obviously not feasible in a network of reasonable
size. LeaTea uses salted\footnote{A salted bloomfilter varies the bit
pattern generated for an entry based on a salt value so that filters
of same size but with different salts will have different
false-positives for the same set of entries.} Bloomfilters
\cite{bloomfilter} that include all
the route targets that a peer knows about in its forward table. So
it does not transport knowledge directly but gives the receiving
peer a tool to check if it knows
something that the sender does not. The receiver can not enumerate
this filter to find out if the sender knows something the receiver
doesn't - but that knowledge is not required in the LeaTea algorithm.

\paragraph{}
Bloomfilter grow in size with number of filtered entries and the
acceptable false-positive rate. The size of the Bloomfilter (in
bytes) in relation to the number of peers $n$ is shown for different
accepted false-positive rates\footnote{If the false-positive rate is
larger than $\frac{1}{n}$, the bloomfilter size is set in italics.}
in table \ref{tbl:bloom}.

\begin{table}[ht]
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Number} & \multicolumn{4}{c|}{\textbf{Size (in bytes) per fp rate}} \\
    \cline{2-5}
    \textbf{of peers} & \textbf{1‰}  & \textbf{2‰} & \textbf{5‰} & \textbf{1\%} \\
    \hline
    10 & 18 & 13 & 11 & 9 \\
    20 & 36 & 26 & 22 & 18 \\
    50 & 91 & 63 & 54 & \textit{45} \\
    100 & 181 & 127 & \textit{109} & \textit{91} \\
    200 & 361 & \textit{253} & \textit{217} & \textit{181} \\
    500 & 902 & \textit{632} & \textit{541} & \textit{451} \\
    1000 & 1804 & \textit{1263} & \textit{1082} & \textit{902} \\
    2000 & \textit{3607} & \textit{2525} & \textit{2164} & \textit{1804} \\
    5000 & \textit{9017} & \textit{6312} & \textit{5410} & \textit{4509} \\
    \hline
  \end{tabular}
  \caption{Bloomfilter sizes for different number of nodes and false-positive rates}
  \label{tbl:bloom}
\end{table}

\paragraph{Example:} If we assume that 802.11 is used by the peers
to communicate with each other, our LEArn message can be around 2kB
in size. This implies that $\approx$1000 peers can be in the ad-hoc
network with a low false-positive rate of 1‰ -- or $\approx$2000 peers
with a rate of 5‰. The impact of the false-positive rate on the efficiency
of the routing is analyzed in more detail in section \ref{sec:measure}.

\paragraph{}
For implementations of the algorithm on real-world devices there are
also other limiting factors; most prominently the amount of RAM required
to store the forward table of the peer, the CPU speed of the device and
the available bandwith in wireless communication. While these points are
not an issue with modern consumer devices (Smartphone, Laptops,...),
it can be a problem for very small embedded devices.

\paragraph{RAM requirement}
Given the current reference implementation of the algorithm
\footnote{see https://github.com/bfix/leatea}, the size a forward entry
is 55 bytes. Assuming that 1000 peers are managed (the upper limit found
before), only 55kB of RAM would be required, which seems doable on the
smallest of embedded devices.

\paragraph{CPU speed}
Implementations need to consider CPU speed (performance) for tiny devices.
As can be seen later the algorithm is far from being complex itself or
requiring complex subcomponents. It can be easily implemented in assembler
in a straight-forward and efficient way to run even on ``slow'' devices.

\paragraph{Network bandwidth}
The available bandwidth between peers for control messages (LEArn and TEAch
messages) is impacting the efficiency (and self-healing aspect) of
the algorithm. TEAch messages not being sent
because of network digestion will slow down the information transport -
the network will need ``more time'' to heal itself if peers are
disconnecting. Given the available bandwith with common wireless
technologies this is likely not to be a serious issue.

\paragraph{}
Section \ref{sec:measure} shows some performance data points for the
reference implementation.


\section{Use-cases}
\label{sec:usecase}

\paragraph{}
(Nice examples where LeaTea can be used)

\section{Terminology}
\label{sec:terms}

\paragraph{Peer:}
      A node that is participating in the ad-hoc network. It has a
      globally-unique identifier (PeerID)\footnote{A simple and easy
      way to create globally-unique PeerIDs is to generate a
      long-term EdDSA key pair for the peer on first start-up
      and to use the public EdDSA key as the PeerID.  Signatures
      are likely required by applications build on the routing
      algorithm anyway.}. \textit{self} denotes the identifier of a
      peer (self-reference) in algorithms.
      
\paragraph{Ad-hoc network:}
      In an ad-hoc network, all peers communicate by
      sending and receiving messages over wireless interfaces like
      802.11n or Bluetooth with other peers in their vincinity using
      broadcasts.  With a routing algorithm for such ad-hoc networks,
      peers can exchange messages even with remote peers that can not be
      reached directly.

\paragraph{Routing:}
      Routing is the process of delivering a message from sender
      to recipient if they can not reach each other directly.  In ad-hoc
      networks no centralized authority exists to steer the routing.
      Since the network is also dynamic (peers can join and leave any
      time) and resource-limited, no peer in the network can have
      perfect knowledge of all possible routes to targets at any given
      point in time.

\paragraph{Neighbor:}
      A neighbor of a peer can exchange messages directly with
      the peer.

\paragraph{Forward table}
      A list of forward entries locally maintained by a
      peer that is utilized in forwarding messages to a destination.
      
\paragraph{Forward entry:}
      An element of a forward table that holds information
      about a target peer, the next hop on the route, the expected
      number of hops to reach the target and the age\footnote{The
      node stores an absolute timestamp in the entry; if the entry is
      send to other peers, the age is computed at the time the
      message was sent. Communicating ages instead of timestamps
      does not require a synchronized time across the nodes in the network.
      The delay between sending and receiving the message is ignored.}
      of the entry.  The information is used by a peer to forward a
      message to the next hop. For more details see \ref{sec:forward}.

\section{Forward table}

\paragraph{}
The LeaTea routing algorithm is based on forward tables; each node in
the network maintains its own table.  A forward table is a list of
forward entries; each forward entry holds (among other) information
about a target peer, the next hop on the route, the expected number
of hops to reach the target and the age\footnotemark[\value{footnote}]
of the entry.

\paragraph{}
If a peer wants to send a higher-level message to a target, it looks
up the matching entry in the forward table and sends the message to
the next hop which must be is one of its neighbors so the message
can be send directly.  The neighbor than applies the same forwarding
process with its own table; the forwarding is repeated until the
target is reached.

\paragraph{}
Forward tables are an efficient instrument for peers to route to any
other peer without having to know about all the other peer
connections that may exist in the network.  But this has also a
drawback: if some remote node is disappearing which was essential for
a route to a target, that information would not be immediatly
available in the local forward table.  This can lead to broken routes
(and even routing cycles) on some of the routes a peer may want to
utilize.

\paragraph{}
So the challenge for any routing algorithm based on forward tables is
to update local forward tables fast and reliable.  The LeaTea routing
algorithm uses three control messages for that purpose: A BEACON message,
a LEARN message and a TEACH message. Control messages are only exchanged
with neighbors; they do not propagate through the network as such. What
is propagated from neighbors to neighbor is the knowledge about routes.
each peer (based on the state of its own forward table) decides which
information to share with its neighbors - or to ask for new knowledge.

\paragraph{}
In an ad-hoc network information can only travel at limited speed
through the network.  The limiting factor is the bandwidth available
to a peer for sending and receiving messages.  Better forward tables
on all nodes require better bandwidth all over the network.

\paragraph{}
As the name suggests the routing is based on learning from and
teaching to other peers that are directly connected (its neighbors).
he design of the algorithm is described in this document. The main
purpose of the routing algorithm is to distribute knowledge
about routes through the network to all participating nodes. The better
this knowledge distribution works, the better are the routes available
in a local forward table.

\subsection{Forward entry}
\label{sec:forward}

\paragraph{}
A forward entry holds the following information:

\paragraph{Target}
      A peer identifier of the route destination (PeerID).

\paragraph{Next}
      A peer indentifier of the next hop on the route from
      the local node to the destination. If the next hop is
      empty, the target peer is a direct neighbor of the local
      node. If the next hop in a forward table is set, it must
      be one of the neighbors of the local node.

\paragraph{Hops}
      The number of hops the local forward table expects for a
      message until it reaches the destination. A neighbor has
      a hop count of 0, all active forwards have a hop count
      greater than 0. The value of hop count of an entry can be
      negative to denote a removal or dormant status (see table
      \ref{tbl:kindState} for details)

\paragraph{Origin}
      The timestamp (local time) when the originating entry was
      created. The originating entry is created by a remote peer
      when it detects a change in the status in on of its
      neighboring peer (see \ref{sec:origin} for details).

\paragraph{Pending}
      An entry is marked pending if it has been changed or added
      to the table but that information was not broadcasted to
      neighbors yet. The pending flag is used to decide if an
      (additional) entry is included in a TEACH message.

\paragraph{}
A forward in the table is unique with respect to the target
peer; only one (or none) forward exists for each possible target.
Throughout this document the notation
$(target,next,hop,origin,pending)$ will be used to denote forwards.

\paragraph{}
There are two \textit{kind} of forwards:
\begin{itemize}
 \item \textbf{Neighbor}: A forward for a direct neighbor of
 the local peer. It must have an empty next hop and a hop count of
 0 to denote an active neighbor. If a neighbor is disappearing,
 the hop count  is set to -2 to indicate a removed neighbor (see
 \ref{sec:removal} for more details. Once the removal of a neighbor
 has been broadcasted  to the network, the hop count of a  removed
 neighbor is set to -3  to indicate a dormant neighbor.
 Dormant neighbors are never removed from the forward table, but
 they will be resurrected once the neighbor reappears.
 \item \textbf{Relay}: A relay can only be learned from
 TEACH messages (see \ref{sec:teach} for details). The next hop is
 the peer the forward was learned from and the hop count represents
 the expected number of hops to reach the target. It is increased by
 one each time it is learned by a peer from a teacher.
\end{itemize}

\paragraph{}
Forwards can be in three different \textit{state}s:
\begin{itemize}
 \item \textbf{Active}: An active forward is used for message routing.
 Active neighbors have a hop count of 0; active relays have a hop
 count greater than 0 (representing the expected number of hops to
 reach the target).
 \item \textbf{Removed}: A forward can be flagged ``removed'' either
 because a neighbor disappears or the removal was learned from a
 TEACH message.
 \item \textbf{Dormant}; A dormant forward is a removed forward that
 was broadcasted in a TEACH message. Dormant forwards can be resurrected
 either by receiving a BEACON message (neighbor) or by learning a
 forward from a TEACH message (relay).
\end{itemize}

\paragraph{}
\textit{Kind} and \textit{state} are encoded into the \textit{Hops}
attribute. The table \ref{tbl:kindState} shows the mapping between
\textit{kind}, \textit{state} and \textit{Hops}.

\paragraph{}
\begin{table}[ht]
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{||c|c|c||}
    \hline
    \textbf{Hops} & \textbf{Kind} & \textbf{State} \\
    \hline
    $>$ 0 & Relay & \multirow{2}{*}{Active} \\
    \cline{1-2}
    = 0 & Neighbor & \\
    \hline
    = -1 & Relay & \multirow{2}{*}{Removed} \\
    \cline{1-2}
    = -2 & Neighbor & \\
    \hline
    = -3 & Relay & \multirow{2}{*}{Dormant} \\
    \cline{1-2}
    = -4 & Neighbor & \\
    \hline
  \end{tabular}
  \caption{Mapping between hop count and kind/state of forward}
  \label{tbl:kindState}
\end{table}


\subsubsection{Originating entry}
\label{sec:origin}

\paragraph{}
The origin of all forward entries are neighbor entries (on a possibly
remote peer). They are added or updated each time they are detected
(see \ref{sec:beacon}) and their origin timestamp is the time of
detection. If a peer announces (see \ref{sec:teach}) its neighbor,
a receiving peer might create a relay entry for the foreign neigbor.
If this relay is announced it might lead to derived relays (with
increased hop count) in other peers. Relays preserve the timestamp
of the originating (neighbor) entry. The origin timestamp is used
to evaluate if a learnable forward is better than the existing entry.

\section{Message handling}

\paragraph{}
Each peer exchanges messages with all neighbors to signal its
presence (BEACON message), a request to learn about new routes
(LEARN message) and a message with entries from its forward
table that may be useful to neighbors (TEACH message). PACKET
messages between peers (that are routed to their destination).
All messages share a common header.

\subsubsection{Message header}

\paragraph{Type}
      = BEACON $|$ LEARN $|$ TEACH $|$ PACKET

\paragraph{Sender}
      The peer identifier of the sender of the message.

\subsection{BEACON message}
\label{sec:beacon}

\paragraph{}
A Beacon message only contains the message header and no additional
data. It is sent periodically (e.g. every second) to signal its
presence to its neighbors. No response is expected or needed.

\paragraph{}
If a neighbor does not send a beacon within a defined period of
time (e.g. five seconds), the entry is tagged as ``removed''.
In both cases the entry is marked as pending and will be send
in one of the next TEACH messages.

\subsubsection{Message handling}

\paragraph{}
When a peer receives a beacon message from one of its neighbors (the
sender), it adds the entry $(sender,-,0,now,now,true)$ to the table,
replacing any existing entry for the sender.

\subsection{LEARN message}

\paragraph{}
Each peer sends out LEARN messages periodically (e.g. every 10 seconds)
to its neighbors. With a LEARN message a peer signals ``This is what I
already know and I want to learn more''. The ``What I already know''
part is basically the forward table of the peer. Since the size of a
forward table can get large in a network with many nodes, it is not
suitable to be send in messages directly.

\paragraph{}
LeaTea uses salted bloomfilters to communicate the `what I know'' information to its neighbors. It traverses its forward
table and decides which entries are considered ``known \& good''. The
PeerID of such entries is added to the bloomfilter; the PeerID of the
sending peer is also included.

\paragraph{}
The bloomfilter is salted with a random number for each LEARN message.
As bloomfilters can lead to false-positives (a PeerID is filtered out
even if it is in fact not included in the filter), a salted bloomfilter
will have different false-positives for each salt; ``mistakes'' are
``corrected'' the next time a LEARN message is sent.

\subsubsection{Message format}

\paragraph{}
A LEARN message contains the message header and a bloomfilter
representing the current state of the forward table (what targets
are known to the peer).

\subsubsection{Sending a LEARN message}

\paragraph{}
The bloomfilter for the message is created using the following steps:
\begin{enumerate}
  \item Create a new bloomfilter with a random salt. The size of the
  bloomfilter is based on the total number of entries in the forward
  table. Implementations may cap the list to fit into a transport
  message.
  \item Add the target of entries from the forward table to the
  bloomfilter if the entry is not in dormant state.
  \item Add ourself to the filter
\end{enumerate}

\subsubsection{Receiving a LEARN message}

\paragraph{}
Upon receiving a LEARN message, peers could reply with a TEACH
message if they have new information about targets to convey to
a LEARN sender. If no new information is available, no TEACH message
is sent. Sending TEACH messages is described in section
\ref{sec:teach}.

\subsection{TEACH message}\label{sec:teach}

\paragraph{}
A TEACH message can be considered a response to a LEARN message; it
is send by a peer if its forward table contain entries not filtered-out
by the LEARN message. It contains a list of forward announcements; a
forward announcement has the same attributes as a forward entry in the
forward table with one exception: Instead of the timestamp of its
origin, the forward announcement uses the $age$ of the forward at the
time the message is sent. It is important that $age$ is expressed as
a relative time instead of an absolute time\footnote{As mentioned
earlier there is no synchronized time across the peers in an ad-hoc
network. Only relative times can be communicated.}. Forward announcements
have the same $kind$ and $state$ values as forward entries\footnote{Except for the $dormant$ state that never occurs in announcements}.

\subsubsection{Message format}

\paragraph{}
A TEACH message contains a list of forward announcements $[a_i]$;
a forward announcement is denoted as $(t,n,h,a)$ referencing the
target peer, next hop, hop count and age.

\subsubsection{Sending a TEACH message}

\paragraph{}
The list of announcements is build by first building a list of
forward candidates from the forward table. Each candidate gets a
\textit{priority} assigned based on the evaluation of the forward
(the following list is sorted with higher priority first):

\begin{itemize}
  \item unfiltered forward
  \item removed neighbor
  \item removed relay
  \item pending forward
\end{itemize}

Note that dormant forwards are never included in a TEACH message,
removed forwards are always selecred as candidates and active forwards
are only included if they have changed recently or are not filtered
out by the LEARN message.

\paragraph{}
The list of candidates is sorted by descending priority (primary) and
descending hop count (secondary). If the list is longer than a defined
maximum\footnote{The number of forward announcements in a TEACH message
is probably limited by the transport mechanism, e.g. the maximum
transport unit (MTU) of a message.} it is trimmed at the end. The
candidates are than used to build the announcement list; included
forwards have their \textit{pending} flag reset.

\subsubsection{Receiving a TEACH message}
\label{sec:learnTeach}

\paragraph{}
An important factor in the LeaTea algorithm is that a TEACH message is
not only received by a LEARN sender but any neighbor of the teaching
peer. This way peers can learn new routing information even if they
have not explicitly asked for knowledge by sending a LEARN message.

\paragraph{}
A peer receiving a TEACH message iterates over the forward
announcements in the message. An announcement $a_i = (target,next,hop,age)$
is discarded if the target is the peer itself; otherwise the
corresponding forward in the local forward table is inspected
\footnote{After each bullet point the algorithm continues with the
next announcement.}:

\paragraph{No forward found:}
\begin{enumerate}
  \item If the annoncement is a removed neighbor, it is directly added
  to the forward table. The \textit{Origin} timestamp is recalculated
  from the the $age$ of the announcement.
  \item If the announcement is in \textit{active} state, it is added
  as a new forward $e = (a_i.target,sender,a_i.hops+1,a_i.age,now,true)$
  to the forward table.
\end{enumerate}

\paragraph{Forward $e_j$ found:}
If $e_j$ is in \textit{removed} state, the announcement is discarded to
not interrupt the pending \textit{state} transition
$removed \rightarrow dormant$ of the forward.
If $e_j$ is not \textit{removed}, the \textit{pending} flag is reset.

\subparagraph{$a_i$ is in \textit{removed state}:}
A \textit{removal} announcement wants to teach the removal of a route
or destination. Removals are acceptable (or not) under the following
conditions:

\begin{enumerate}
  \item \textbf{$e_j$ is not \textit{active}}: Only active forwards
  can be removed; the announcement is discarded.
  \item \textbf{$a_j$ is older\footnote{To allow for latencies in
  transmission and processing of messages it is recommended to define
  \textit{older} as $a_i.age - e_j.age < \varepsilon$ with $\varepsilon$
  e.g. one second.} than $e_j$}: Old announcements could not remove
  newer forwards. The announcement is discarded.
  \item \textbf{$e_j$ is a neighbor}: Flag $e_j$ as pending and
  discard the annoncement.
  \item \textbf{$e_j.next$ = sender}: An active forward to \textit{sender}
  is removed (flag $e_j$ as \textit{removed}).
  
\end{enumerate}

\subparagraph{Forward $e_j$ is a \textit{relay}:}
If $e_j$ is dormant or a newer announcemnt proposes a shorter route,
$e_j$ is a candidate for update. To prevent loops between two peers,
it must also be checked if $(e_j.next = sender \,\wedge\, a_i.next = self)$
holds true; if so the announcement is discarded. Otherwise the forward
in the table is updated as $(e_j.target,sender,a_i.hops+1,a_i.age,now,true)$.

\subparagraph{Forward $e_j$ is a \textit{dormant neighbor}:}
The forward in the table is updated as
$(e_j.target,sender,a_i.hops+1,a_i.age,now,true)$.

\paragraph{}
The pseudocode \ref{alg:learn} illustrates the LEARN process.

\begin{algorithm}[ht]
  \caption{Learning a TEACH message from sender}
  \label{alg:learn}
  \SetKw{Continue}{continue}
  \SetKw{And}{and}
  \SetKw{uEndIf}{end if}
  \SetKw{Or}{or}
  \SetKwInOut{KwIn}{Input}
  \KwIn{announcements $a$, sender, forward table $e$ }

  \For{each announcement $a_i$}{
    \If{$a_i.target = self$}{
      \Continue
    }
    
    $e_j \leftarrow$ table entry matching $a_i$ with $e_j.target = a_i.target$
    
    \eIf{$e_j$ not found}{
      \uIf{$a_i$ is removed neighbor}{
        $e_j \leftarrow a_i$
      }
      \uElseIf{$e_j$ is an active forward}{
        $e_j \leftarrow (a_i.target,sender,a_i.hops+1,a_i.age,now,true)$
      }
      \uEndIf
    }{
      \uIf{$a_i$ is removed}{
        \If{$e_j$ is active \And $e_j$ is older than $a_i$}{
          \uIf{$e_j$ is a neighbor}{
            flag $e_j$ as \textit{pending}
          }
          \uElseIf{$e_j.next = sender$}{
            flag $e_j$ as \textit{removed}
          }
        }
      }
      \uElseIf{$e_j$ is a relay}{
        \If{$e_j$ is dormant \Or $a_i$ is a shorter route}{
          \If{$e_j.next \neq sender$ \Or $a_i.next \neq self$}{
            $e_j \leftarrow (a_i.target,sender,a_i.hops+1,a_i.age,now,true)$
          }
        }
      }
      \uElseIf{$e_j$ is a dormant neighbor}{
        $e_j \leftarrow (a_i.target,sender,a_i.hops+1,a_i.age,now,true)$
      }
      \uEndIf
    }
  }
\end{algorithm}

\section{Removing forwards: Self-healing tables}

\paragraph{}
If a peer has been active on the network for at least some time, it
was detected by its neighbors and added to their respective forward
tables.  The information about the peer is propagated through the
network so that remote peers can learn about it too.

\paragraph{}
If a peer disappears for some reason, only its former neighbors can
detect that the peer is no longer available.  LeaTea does not rely on
a "sign-off" message from the peer to its neighbors but detects a
lost peer by looking at the age of the corresponding entry in the
forward table: If the peer was a neighbor and the entry age exceeds a
defined limit, the peer is considered lost.  The age for the entry is
reset (re-born) if the peer reappears later.

\paragraph{}
To understand what happens when a neighboring peer disappears, consider
a simple network of eight peers\footnote{The network layout may seem
strange, but consider it a 2D projection of 3D-placed nodes} as shown in
figure \ref{gr:net1}; assume that the forward tables are settled in all
eight peers (each peer knows routes to all other peers) and that peer 6
is going to disappear.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[scale=1.5,auto=center,every node/.style={circle,fill=blue!20}] 
    \node (1) at (1,3) {1};
    \node (2) at (3,3) {2};
    \node (3) at (5,3) {3};
    \node (4) at (2,1) {4};
    \node (5) at (4,1) {5};
    \node (6) at (3,2) {6};
    \node (7) at (6,2) {7};
    \node (8) at (7,1) {8};
    \draw (1) -- (2);
    \draw (1) -- (4);
    \draw (2) -- (3);
    \draw (2) -- (6);
    \draw (3) -- (5);
    \draw (3) -- (7);
    \draw (4) -- (5);
    \draw (4) -- (6);
    \draw (6) -- (7);
    \draw (7) -- (8);
  \end{tikzpicture}
  \caption{Simple ad-hoc network}
  \label{gr:net1}
\end{figure}

\paragraph{}
The forward table\footnote{Please note that the \textit{origin} of an
entry in this table is represented as an \textit{age}} of peer 4
before the removal of peer 6 is shown in table \ref{tbl:p4before}.
Peer 4 for example knows a route to peer 7 via peer 6 (the shortest
route possible); this route will be invalidated once peer 6 disappears.

\paragraph{}
\begin{table}[ht]
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{||c|c|c|c||}
    \hline
    \textbf{Target} & \textbf{Next} & \textbf{Hops} & \textbf{Age} \\
    \hline
    1 & 0 & 0 & 0.147 \\
    \hline
    2 & 6 & 1 & 40.020 \\
    \hline
    3 & 5 & 1 & 46.914 \\
    \hline
    5 & 0 & 0 & 0.640 \\
    \hline
    6 & 0 & 0 & 0.850 \\
    \hline
    7 & 6 & 1 & 25.179 \\
    \hline
    8 & 6 & 2 & 23.277 \\
    \hline
  \end{tabular}
  \caption{Forward table of peer 4 before removal of peer 6}
  \label{tbl:p4before}
\end{table}

\paragraph{}
Focussing on peer 4, we will see the following sequence of events after
the removal of peer 6:

\paragraph{Peer 4 detects that neighbor 6 expired:} All forwards
with peer 6 as next hop (the routes to peer 2, peer 7 and peer 8)
are removed\footnote{Only changed entries are shown}:

\parbox{11cm}{
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{||c|c|c|c||}
    \hline
    \textbf{Target} & \textbf{Next} & \textbf{Hops} & \textbf{Age} \\
    \hline
    2 & 6 & -3 & 9.322 \\
    \hline
    6 & 0 & -4 & 9.322 \\
    \hline
    7 & 6 & -3 & 9.322 \\
    \hline
    8 & 6 & -3 & 9.322 \\
    \hline
  \end{tabular}
}

\paragraph{Peer 4 is teaching} its neighbors about the four removed forwards
(one neighbor, three relays).

\paragraph{Peer 4 learns}
\begin{itemize}
  \item \textbf{a new forward to peer 2 from peer 1}:\\
  $a_i: (2,1,1,0.698), e_j: (2,6,-3,10.000) \rightarrow (2,1,1,0.698)$

  \item \textbf{a new forward to peer 7 from peer 5}:\\
  $a_i: (7,5,2,65.858), e_j: (7,6,-3,10.000) \rightarrow (7,5,2,65.858)$

  \item \textbf{a new forward to peer 8 from peer 5}:\\
  $a_i: (8,5,3,66.364), e_j: (8,6,-3,12.408) \rightarrow (8,5,3,66.364)$
\end{itemize}

\paragraph{}
After these steps the forward table of peer 4 is ``repaired''; valid
routes to all other peers exist:

\begin{table}[ht]
  \centering
  \setlength{\tabcolsep}{10pt}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{||c|c|c|c||}
    \hline
    \textbf{Target} & \textbf{Next} & \textbf{Hops} & \textbf{Age} \\
    \hline
    1 & 0 & 0 & 0.147 \\
    \hline
    2 & 1 & 1 & 10.020 \\
    \hline
    3 & 5 & 1 & 96.914 \\
    \hline
    5 & 0 & 0 & 0.641 \\
    \hline
    6 & 0 & -4 & 19.322 \\
    \hline
    7 & 5 & 2 & 75.180 \\
    \hline
    8 & 5 & 3 & 73.277 \\
    \hline
  \end{tabular}
  \caption{Forward table of peer 4 after removal of peer 6}
  \label{tbl:p4after}
\end{table}

\paragraph{}
As mentioned earlier it is important to understand that peers can
learn new routes even without explicitly asking for new knowledge by
listening to TEACH messages sent by neighbors (as a repsonse to a LEARN
message sent by another peer that is not necessarily a neighboring peer
for the learner.

\clearpage
\section{Ad-hoc network simulations}
\label{sec:measure}

\paragraph{}
The reference implementation was used to simulate ad-hoc networks of
different size and environmental impacts (like walls blocking direct
communication between ``near'' peers). The results for these simulations
is presented here.

\subsection{Simulation environment}

\paragraph{}
The simulation environment\footnote{Server with 96 cores (AMD EPYC 7451)
and 256GB memory; all resources mainly dedicated to the simulation.}
runs a given number of nodes concurrently; nodes appear
randomly\footnote{Distributed on a 100$\times$100 square with an initial
delay (exponential distribution).}; peer and route discovery starts once
neighbors detect each other. All peers have the same sender/receiver
characteristics, adjusted to peer density in the simulation\footnote{The
broadcast range is constant for all peers and is set to a value that does
not exclude a peer (or group of peers) from the network - all peers are
technically fully connected.}.

\subsubsection{CPU and memory requirements}

\paragraph{}
The CPU and memory requirements of the simulations (50, 100, 200, 500, 1000
and 2000 peers) are shown in figure \ref{fig:resource}. Please note that the
simulation for 2000 peers hits the CPU resource limit; message processing (and
memory management / garbage collection) is delayed beyond reasonable limits;
the results are only included for completeness. Ressource consumptionis relatively
constant once all peers have started. The spike in CPU usage at the start of
the simulation is caused by initializing all peers with an EdDSA key pair
\cite{ed25519}; the public EdDSA key is used as the peer identifier.

\begin{figure}
  \centering
  \textbf{50 peers} \hfill \textbf{100 peers} \\
  \includegraphics[width=.49\textwidth]{monitor-50.png}\hfill
  \includegraphics[width=.49\textwidth]{monitor-100.png}\\
  \textbf{200 peers} \hfill \textbf{500 peers} \\
  \includegraphics[width=.49\textwidth]{monitor-200.png}\hfill
  \includegraphics[width=.49\textwidth]{monitor-500.png}\\
  \textbf{1000 peers} \hfill \textbf{2000 peers} \\
  \includegraphics[width=.49\textwidth]{monitor-1000.png}\hfill
  \includegraphics[width=.49\textwidth]{monitor-2000.png}\\
  \begin{tikzpicture}
    \begin{semilogxaxis}[
      scale=0.7,
      axis y line*=left,
      ymin=-0.1, ymax=6000,
      ylabel = {\%CPU},
      ylabel style={color=red},
      xlabel = {Peers}
     ]
	  \addplot [color=red,line width=1.1] coordinates {
        (50,8)(100,38)(200,150)(500,1100)(1000,5000)
      };
    \end{semilogxaxis}
    \begin{semilogxaxis}[
      scale=0.7,
      axis x line*=top,
      axis y line*=right,
      ymin=-0.1, ymax=400,
      ylabel = {RAM (MB)},
      ylabel style={color=blue},
    ]
	  \addplot [color=blue,line width=1.1] coordinates {
        (50,8)(100,20)(200,30)(500,85)(1000,375)
      };
    \end{semilogxaxis}
    \begin{semilogxaxis}[
      scale=0.7,
      ticks=none,
      xmin=0, xmax=1200,
      ymin=-0.1, ymax=1000,
    ]
      \addplot[
        domain=50:1000,
        samples=25, 
        color=gray,
        dotted,
        line width=2,
      ] {x*x/850};
    \end{semilogxaxis}
  \end{tikzpicture}
  \caption{CPU / memory usage during simulations}
  \label{fig:resource}
\end{figure}

\paragraph{}
As expected CPU and memory requirements grow quadratically (see the dotted
curve in the last graph of figure \ref{fig:resource}) limiting the number
of peers in a network simulation.

\subsubsection{Network traffic}

\paragraph{}
The network traffic per peer (and per neighbor) is shown in figure
\ref{fig:traffic}. The values are scaled per neighbor; the average
number of neigbors varies between seven and eleven\footnote{A higher
number of peers makes it more likely for more other peers to show up
in a single broadcast range. THe simulation parameters are designed 
that no peer is outside the network or that the peers are grouped in
``islands'' in a partinioned network} peers. Network traffic is
moderate even for larger networks (average receiving rate
is ~3kB for 500 peers, sending is even lower).

\begin{figure}[ht]
  \centering
  \textbf{Traffic per peer}\hfill\textbf{Traffic per neighbor}\\
  \begin{tikzpicture}
    \begin{semilogxaxis}[
      scale=0.5,
      axis y line*=left,
      xmin=0, xmax=1000,
      ymin=0, ymax=1000,
      ylabel = {kB received},
      ylabel style={color=red},
      xlabel = {Peers}
     ]
      \addplot+[
        color=red,
        line width=1.1,
        error bars/.cd,
        y dir=both,
        y explicit,
      ] coordinates {
        (50,161.46) +- (0,54.99)
        (100,202.76) +- (0,68.6)
        (200,307.25) +- (0,103.11)
        (500,928.26) +- (0,303.01)
      };
    \end{semilogxaxis}
    \begin{semilogxaxis}[
      scale=0.5,
      axis x line*=top,
      axis y line*=right,
      xmin=0, xmax=1000,
      ymin=20, ymax=120,
      ylabel = {kb sent},
      ylabel style={color=blue},
    ]
      \addplot+[
        color=blue,
        line width=1.1,
        error bars/.cd,
        y dir=both,
        y explicit,
      ] coordinates {
        (50,24.04) +- (0,2.72)
        (100,30.96) +- (0,4.76)
        (200,43.79) +- (0,6.98)
        (500,84.21) +- (0,14.15)
      };
    \end{semilogxaxis}
  \end{tikzpicture}\hfill
    \begin{tikzpicture}
    \begin{semilogxaxis}[
      scale=0.5,
      axis y line*=left,
      xmin=0, xmax=1000,
      ymin=0, ymax=100,
      ylabel = {kB received},
      ylabel style={color=red},
      xlabel = {Peers}
     ]
      \addplot+[
        color=red,
        line width=1.1,
        error bars/.cd,
        y dir=both,
        y explicit,
      ] coordinates {
        (50,22.68) +- (0,7.72)
        (100,28.64) +- (0,9.69)
        (200,40.97) +- (0,13.75)
        (500,75) +- (0,25.87)
      };
    \end{semilogxaxis}
    \begin{semilogxaxis}[
      scale=0.5,
      axis x line*=top,
      axis y line*=right,
      xmin=0, xmax=1000,
      ymin=3, ymax=14,
      ylabel = {kb sent},
      ylabel style={color=blue},
    ]
      \addplot+[
        color=blue,
        line width=1.1,
        error bars/.cd,
        y dir=both,
        y explicit,
      ] coordinates {
        (50,3.38) +- (0,0.37)
        (100,4.33) +- (0,0.65)
        (200,5.84) +- (0,0.92)
        (500,8.81) +- (0,1.45)
      };
    \end{semilogxaxis}
  \end{tikzpicture}
  \caption{Network traffic (per node / per neighbor)}
  \label{fig:traffic}
\end{figure}

\subsection{Simulations}

\subsubsection{Nodes appearing over time}

\paragraph{}
Figure \ref{fig:convergance} shows how the routes converge against the
optimum (shortest routes without loops and broken routes) for different
network sizes. The time for the network to reach a stable state (no more
route changes) is relatively independent of the network size (number of
nodes); it only increases slightly due to the fact that peers in larger
networks are separated by more hops than peers in smaller networks - and
the propagation of route information needs to traverse the whole network.
For practical applications this difference can be neglected.

\begin{figure}[ht]
  \centering
  \textbf{50 peers}\hfill\textbf{100 peers}\\
  \pgfplotstableread[col sep=comma]{stat-50.csv}{\chartdata}
  \begin{tikzpicture}
    \begin{axis}[
        title={},
        scale=0.5,
        xlabel={Time(s)},
        ylabel={},
        xmin=0, xmax=250,
        ymin=0, ymax=3000,
        xtick={0,60,120,180,240,300,360,420},
        ytick={},
        xmajorgrids=false,
        ymajorgrids=false,
        width=0.8\textwidth,
    ]
    % broken routes
    \addplot+[
      mark=none,
      color=red,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{2},
    ]{\chartdata};

    % expected success routes
    \addplot+[
      mark=none,
      color=green,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{4}*(\thisrowno{4}-1),
    ]{\chartdata};
  
    % success routes
    \addplot+[
      mark=none,
      color=blue,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{3},
    ]{\chartdata};

    \end{axis}
  \end{tikzpicture}
  \pgfplotstableread[col sep=comma]{stat-100.csv}{\chartdata}
  \begin{tikzpicture}
    \begin{axis}[
        title={},
        scale=0.5,
        xlabel={Time(s)},
        ylabel={},
        xmin=0, xmax=300,
        ymin=0, ymax=12000,
        xtick={0,60,120,180,240,300,360,420},
        ytick={},
        xmajorgrids=false,
        ymajorgrids=false,
        width=0.8\textwidth,
    ]
    % broken routes
    \addplot+[
      mark=none,
      color=red,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{2},
    ]{\chartdata};

    % expected success routes
    \addplot+[
      mark=none,
      color=green,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{4}*(\thisrowno{4}-1),
    ]{\chartdata};
  
    % success routes
    \addplot+[
      mark=none,
      color=blue,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{3},
    ]{\chartdata};

    \end{axis}
  \end{tikzpicture}\\
  \textbf{200 peers}\hfill\textbf{500 peers}\\
  \pgfplotstableread[col sep=comma]{stat-200.csv}{\chartdata}
  \begin{tikzpicture}
    \begin{axis}[
        title={},
        scale=0.5,
        xlabel={Time(s)},
        ylabel={},
        xmin=0, xmax=360,
        ymin=0, ymax=43000,
        xtick={0,120,240,360,480},
        ytick={},
        xmajorgrids=false,
        ymajorgrids=false,
        width=0.8\textwidth,
    ]
    % broken routes
    \addplot+[
      mark=none,
      color=red,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{2},
    ]{\chartdata};

    % expected success routes
    \addplot+[
      mark=none,
      color=green,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{4}*(\thisrowno{4}-1),
    ]{\chartdata};
  
    % success routes
    \addplot+[
      mark=none,
      color=blue,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{3},
    ]{\chartdata};

    \end{axis}
  \end{tikzpicture}\hfill
  \pgfplotstableread[col sep=comma]{stat-500.csv}{\chartdata}
  \begin{tikzpicture}
    \begin{axis}[
        title={},
        scale=0.5,
        xlabel={Time(s)},
        ylabel={},
        xmin=0, xmax=420,
        ymin=0, ymax=260000,
        xtick={0,120,240,360,480},
        ytick={},
        xmajorgrids=false,
        ymajorgrids=false,
        legend pos=outer north east,     
        width=0.8\textwidth,
    ]
    % broken routes
    \addplot+[
      mark=none,
      color=red,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{2},
    ]{\chartdata};
    \addlegendentry{Broken}

    % expected success routes
    \addplot+[
      mark=none,
      color=green,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{4}*(\thisrowno{4}-1),
    ]{\chartdata};
    \addlegendentry{Expected}
  
    % success routes
    \addplot+[
      mark=none,
      color=blue,
    ] table [
      x expr=\thisrowno{0}*5,
      y expr=\thisrowno{3},
    ]{\chartdata};
    \addlegendentry{Success}

    \end{axis}
  \end{tikzpicture}
  \caption{Convergence of routes}
  \label{fig:convergance}
\end{figure}

\subsubsection{Nodes appearing and disappearing over time}

\paragraph{}
Test

\clearpage
\section{Bibliography}

\bibliography{leatea} 
\bibliographystyle{ieeetr}

\end{document}
